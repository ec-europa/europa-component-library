/**
 * stickybits - Stickybits is a lightweight (~2KB) alternative to `position: sticky` polyfills
 * @version v1.3.7
 * @link https://github.com/dollarshaveclub/stickybits#readme
 * @author Jeff Wainwright <jjwainwright2@gmail.com>
 * @license MIT */
!(function(t, s) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = s())
    : typeof define === 'function' && define.amd
      ? define(s)
      : (t.stickybits = s());
})(this, () => {
  function t(t, s) {
    if (typeof window === 'undefined')
      throw Error('stickybits requires `window`');
    return (this.el = t), (this.offset =
      (s && s.stickyBitStickyOffset) || 0), (this.vp =
      (s && s.verticalPosition) || 'top'), (this.useClasses =
      (s && s.useStickyClasses) ||
      !1), (this.styles = this.el.style), (this.positionVal =
      'fixed'), this.setStickyPosition(), (this.positionVal !== 'fixed' &&
      !0 !== this.useClasses) ||
      this.manageStickiness(), this;
  }
  function s(t) {
    const s = this;
    (this.privateInstances = t || []), (this.cleanup = function() {
      return s.privateInstances.forEach(t => t.cleanup());
    });
  }
  return (t.prototype.setStickyPosition = function() {
    for (
      var t = ['', '-o-', '-webkit-', '-moz-', '-ms-'],
        s = this.styles,
        i = this.vp,
        e = 0;
      e < t.length;
      e += 1
    )
      s.position = `${t[e]}sticky`;
    return s.position !== '' &&
      (
        (this.positionVal = s.position),
        i === 'top' && (s[i] = `${this.offset}px`)
      ), this;
  }), (t.prototype.manageStickiness = function() {
    let t = this.el,
      s = t.parentNode,
      i = this.positionVal,
      e = this.vp,
      n = this.offset,
      o = this.styles,
      a = t.classList,
      r = window,
      c = r.requestAnimationFrame;
    s.classList.add('js-stickybit-parent');
    let f = s.getBoundingClientRect().top,
      u = f + s.offsetHeight - (t.offsetHeight - n),
      p = 'default';
    return (this.manageState = function() {
      let t = r.scrollY || r.pageYOffset,
        s = t > f && t < u && (p === 'default' || p === 'stuck'),
        l = t < f && p === 'sticky',
        h = t > u && p === 'sticky';
      s
        ? (
            (p = 'sticky'),
            c(() => {
              a.add('js-is-sticky'), a.contains('js-is-stuck') &&
                a.remove('js-is-stuck'), (o.bottom = ''), (o.position = i), (o[
                e
              ] = `${n}px`);
            })
          )
        : l
          ? (
              (p = 'default'),
              c(() => {
                a.remove('js-is-sticky'), i === 'fixed' && (o.position = '');
              })
            )
          : h &&
            (
              (p = 'stuck'),
              c(() => {
                a.remove('js-is-sticky'), a.add('js-is-stuck'), i === 'fixed' &&
                  ((o.top = ''), (o.bottom = '0'), (o.position = 'absolute'));
              })
            );
    }), r.addEventListener('scroll', this.manageState), this;
  }), (t.prototype.cleanup = function() {
    let t = this.el,
      s = this.styles;
    (s.position = ''), (s[this.vp] = ''), t.classList.remove(
      'js-is-sticky',
      'js-is-stuck'
    ), t.parentNode.classList.remove(
      'js-stickybit-parent'
    ), window.removeEventListener(
      'scroll',
      this.manageState
    ), (this.manageState = !1);
  }), function(i, e) {
    let n = typeof i === 'string' ? document.querySelectorAll(i) : i;
    'length' in n || (n = [n]);
    for (var o = [], a = 0; a < n.length; a += 1) {
      const r = n[a];
      o.push(new t(r, e));
    }
    return new s(o);
  };
});
